# YouTube Transcription Plugin Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Build an Obsidian plugin that extracts YouTube video transcripts, generates AI summaries using local LLMs, and saves formatted notes to the vault.

**Architecture:** Service-oriented design with YouTube, LLM, and Template services. Multiple UI entry points (modal, ribbon, context menu) feed into a single processing pipeline with status bar feedback.

**Tech Stack:** TypeScript, Obsidian API, youtube-transcript, ytdl-core, Obsidian plugin architecture

---

## Task 1: Project Initialization and Setup

**Files:**
- Create: `package.json`
- Create: `tsconfig.json`
- Create: `manifest.json`
- Create: `.gitignore`
- Create: `esbuild.config.mjs`

**Step 1: Create package.json**

```json
{
  "name": "ytextract",
  "version": "1.0.0",
  "description": "Extract YouTube transcripts and generate AI summaries",
  "main": "main.js",
  "scripts": {
    "dev": "node esbuild.config.mjs",
    "build": "tsc -noEmit -skipLibCheck && node esbuild.config.mjs production",
    "version": "node version-bump.mjs && git add manifest.json versions.json"
  },
  "keywords": [],
  "author": "",
  "license": "MIT",
  "devDependencies": {
    "@types/node": "^20.10.0",
    "@typescript-eslint/eslint-plugin": "^6.13.0",
    "@typescript-eslint/parser": "^6.13.0",
    "builtin-modules": "^3.3.0",
    "esbuild": "^0.19.8",
    "obsidian": "latest",
    "tslib": "^2.6.2",
    "typescript": "^5.3.2"
  },
  "dependencies": {
    "youtube-transcript": "^1.0.6",
    "ytdl-core": "^4.11.5"
  }
}
```

**Step 2: Create tsconfig.json**

```json
{
  "compilerOptions": {
    "baseUrl": ".",
    "inlineSourceMap": true,
    "inlineSources": true,
    "module": "ESNext",
    "target": "ES6",
    "allowJs": true,
    "noImplicitAny": true,
    "moduleResolution": "node",
    "importHelpers": true,
    "isolatedModules": true,
    "strictNullChecks": true,
    "lib": [
      "DOM",
      "ES5",
      "ES6",
      "ES7"
    ]
  },
  "include": [
    "**/*.ts"
  ]
}
```

**Step 3: Create manifest.json**

```json
{
  "id": "ytextract",
  "name": "YouTube Transcript Extractor",
  "version": "1.0.0",
  "minAppVersion": "0.15.0",
  "description": "Extract YouTube transcripts and generate AI-powered summaries using local LLMs",
  "author": "Your Name",
  "authorUrl": "https://yourwebsite.com",
  "fundingUrl": "",
  "isDesktopOnly": false
}
```

**Step 4: Create .gitignore**

```
# npm
node_modules

# build
main.js
*.js.map

# obsidian
data.json

# macOS
.DS_Store
```

**Step 5: Create esbuild.config.mjs**

```javascript
import esbuild from 'esbuild';
import process from 'process';
import builtins from 'builtin-modules';

const banner = `/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/
`;

const prod = process.argv[2] === 'production';

const context = await esbuild.context({
  banner: {
    js: banner,
  },
  entryPoints: ['src/main.ts'],
  bundle: true,
  external: [
    'obsidian',
    'electron',
    '@codemirror/autocomplete',
    '@codemirror/collab',
    '@codemirror/commands',
    '@codemirror/language',
    '@codemirror/lint',
    '@codemirror/search',
    '@codemirror/state',
    '@codemirror/view',
    '@lezer/common',
    '@lezer/highlight',
    '@lezer/lr',
    ...builtins
  ],
  format: 'cjs',
  target: 'es2018',
  logLevel: 'info',
  sourcemap: prod ? false : 'inline',
  treeShaking: true,
  outfile: 'main.js',
});

if (prod) {
  await context.rebuild();
  process.exit(0);
} else {
  await context.watch();
}
```

**Step 6: Install dependencies**

Run: `npm install`
Expected: Dependencies installed successfully

**Step 7: Commit**

```bash
git init
git add .
git commit -m "chore: initialize Obsidian plugin project"
```

---

## Task 2: TypeScript Types and Interfaces

**Files:**
- Create: `src/models/types.ts`

**Step 1: Write types for plugin settings**

```typescript
export interface YTExtractSettings {
  // File Management
  defaultFolder: string;
  namingPattern: string;
  templatePath: string;
  fileExistsBehavior: 'append' | 'prompt';

  // Metadata Fields
  includeUploadDate: boolean;
  includeDuration: boolean;
  includeViewCount: boolean;
  includeDescription: boolean;
  includeChannelUrl: boolean;
  includeThumbnailUrl: boolean;

  // LLM Configuration
  llmProvider: 'ollama' | 'lmstudio' | 'llamacpp' | 'custom';
  autoDetectEndpoint: boolean;
  llmEndpoint: string;
  llmModel: string;
  customSystemPrompt: string;
  outputSummary: boolean;
  outputKeyPoints: boolean;
  outputTags: boolean;
  outputQuestions: boolean;
  requestTimeout: number;

  // Error Handling
  errorBehavior: 'stop' | 'partial' | 'skip';
}

export const DEFAULT_SETTINGS: YTExtractSettings = {
  defaultFolder: '',
  namingPattern: '{date} - {title}',
  templatePath: '',
  fileExistsBehavior: 'append',

  includeUploadDate: true,
  includeDuration: true,
  includeViewCount: false,
  includeDescription: false,
  includeChannelUrl: false,
  includeThumbnailUrl: false,

  llmProvider: 'ollama',
  autoDetectEndpoint: true,
  llmEndpoint: 'http://localhost:11434/api/generate',
  llmModel: 'llama2',
  customSystemPrompt: 'Summarize the following transcript concisely and suggest relevant tags',
  outputSummary: true,
  outputKeyPoints: true,
  outputTags: true,
  outputQuestions: false,
  requestTimeout: 30000,

  errorBehavior: 'skip'
};
```

**Step 2: Write types for YouTube data**

Add to `src/models/types.ts`:

```typescript
export interface VideoMetadata {
  title: string;
  url: string;
  videoId: string;
  channel: string;
  uploadDate?: string;
  duration?: string;
  viewCount?: number;
  description?: string;
  channelUrl?: string;
  thumbnailUrl?: string;
}

export interface TranscriptSegment {
  text: string;
  offset: number;
  duration: number;
}

export interface YouTubeData {
  metadata: VideoMetadata;
  transcript: string;
  timestampedTranscript?: TranscriptSegment[];
}
```

**Step 3: Write types for LLM responses**

Add to `src/models/types.ts`:

```typescript
export interface LLMResponse {
  summary?: string;
  keyPoints?: string[];
  tags?: string[];
  questions?: string[];
}

export interface LLMProvider {
  name: string;
  defaultEndpoint: string;
  testConnection(): Promise<boolean>;
  generateSummary(transcript: string, prompt: string): Promise<LLMResponse>;
}
```

**Step 4: Write type for template data**

Add to `src/models/types.ts`:

```typescript
export interface TemplateData {
  // Video metadata
  title: string;
  url: string;
  channel: string;
  upload_date: string;
  duration: string;
  view_count: string;
  description: string;
  channel_url: string;
  thumbnail_url: string;

  // LLM outputs
  llm_summary: string;
  llm_key_points: string;
  generated_tags: string;
  llm_questions: string;

  // Transcript
  transcript: string;
  transcript_timestamped: string;

  // Other
  extraction_date: string;
}
```

**Step 5: Commit**

```bash
git add src/models/types.ts
git commit -m "feat: add TypeScript types and interfaces"
```

---

## Task 3: Plugin Main Entry Point

**Files:**
- Create: `src/main.ts`

**Step 1: Write minimal plugin class**

```typescript
import { Plugin } from 'obsidian';
import { YTExtractSettings, DEFAULT_SETTINGS } from './models/types';

export default class YTExtractPlugin extends Plugin {
  settings: YTExtractSettings;

  async onload() {
    console.log('Loading YouTube Transcript Extractor plugin');

    await this.loadSettings();
  }

  async onunload() {
    console.log('Unloading YouTube Transcript Extractor plugin');
  }

  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }

  async saveSettings() {
    await this.saveData(this.settings);
  }
}
```

**Step 2: Test the build**

Run: `npm run build`
Expected: Build succeeds, main.js created

**Step 3: Commit**

```bash
git add src/main.ts
git commit -m "feat: add plugin main entry point"
```

---

## Task 4: Settings Tab UI

**Files:**
- Create: `src/ui/settings-tab.ts`
- Modify: `src/main.ts`

**Step 1: Write settings tab class structure**

```typescript
import { App, PluginSettingTab, Setting } from 'obsidian';
import YTExtractPlugin from '../main';

export class YTExtractSettingTab extends PluginSettingTab {
  plugin: YTExtractPlugin;

  constructor(app: App, plugin: YTExtractPlugin) {
    super(app, plugin);
    this.plugin = plugin;
  }

  display(): void {
    const { containerEl } = this;
    containerEl.empty();

    containerEl.createEl('h2', { text: 'YouTube Transcript Extractor Settings' });

    this.addFileManagementSettings(containerEl);
    this.addMetadataSettings(containerEl);
    this.addLLMSettings(containerEl);
    this.addErrorHandlingSettings(containerEl);
  }

  private addFileManagementSettings(containerEl: HTMLElement): void {
    containerEl.createEl('h3', { text: 'File Management' });

    new Setting(containerEl)
      .setName('Default folder')
      .setDesc('Default folder to save extracted videos')
      .addText(text => text
        .setPlaceholder('Example: YouTube')
        .setValue(this.plugin.settings.defaultFolder)
        .onChange(async (value) => {
          this.plugin.settings.defaultFolder = value;
          await this.plugin.saveSettings();
        }));

    new Setting(containerEl)
      .setName('Naming pattern')
      .setDesc('File naming pattern. Variables: {date}, {title}, {channel}, {id}')
      .addText(text => text
        .setPlaceholder('{date} - {title}')
        .setValue(this.plugin.settings.namingPattern)
        .onChange(async (value) => {
          this.plugin.settings.namingPattern = value;
          await this.plugin.saveSettings();
        }));

    new Setting(containerEl)
      .setName('Template file path')
      .setDesc('Path to custom template file (leave empty for default)')
      .addText(text => text
        .setPlaceholder('templates/youtube.md')
        .setValue(this.plugin.settings.templatePath)
        .onChange(async (value) => {
          this.plugin.settings.templatePath = value;
          await this.plugin.saveSettings();
        }));

    new Setting(containerEl)
      .setName('File exists behavior')
      .setDesc('What to do when file already exists')
      .addDropdown(dropdown => dropdown
        .addOption('append', 'Append number to filename')
        .addOption('prompt', 'Prompt for overwrite')
        .setValue(this.plugin.settings.fileExistsBehavior)
        .onChange(async (value) => {
          this.plugin.settings.fileExistsBehavior = value as 'append' | 'prompt';
          await this.plugin.saveSettings();
        }));
  }

  private addMetadataSettings(containerEl: HTMLElement): void {
    containerEl.createEl('h3', { text: 'Video Metadata Fields' });

    new Setting(containerEl)
      .setName('Include upload date')
      .setDesc('Include video upload date in template')
      .addToggle(toggle => toggle
        .setValue(this.plugin.settings.includeUploadDate)
        .onChange(async (value) => {
          this.plugin.settings.includeUploadDate = value;
          await this.plugin.saveSettings();
        }));

    new Setting(containerEl)
      .setName('Include duration')
      .setDesc('Include video duration in template')
      .addToggle(toggle => toggle
        .setValue(this.plugin.settings.includeDuration)
        .onChange(async (value) => {
          this.plugin.settings.includeDuration = value;
          await this.plugin.saveSettings();
        }));

    new Setting(containerEl)
      .setName('Include view count')
      .setDesc('Include video view count in template')
      .addToggle(toggle => toggle
        .setValue(this.plugin.settings.includeViewCount)
        .onChange(async (value) => {
          this.plugin.settings.includeViewCount = value;
          await this.plugin.saveSettings();
        }));

    new Setting(containerEl)
      .setName('Include description')
      .setDesc('Include video description in template')
      .addToggle(toggle => toggle
        .setValue(this.plugin.settings.includeDescription)
        .onChange(async (value) => {
          this.plugin.settings.includeDescription = value;
          await this.plugin.saveSettings();
        }));

    new Setting(containerEl)
      .setName('Include channel URL')
      .setDesc('Include channel URL in template')
      .addToggle(toggle => toggle
        .setValue(this.plugin.settings.includeChannelUrl)
        .onChange(async (value) => {
          this.plugin.settings.includeChannelUrl = value;
          await this.plugin.saveSettings();
        }));

    new Setting(containerEl)
      .setName('Include thumbnail URL')
      .setDesc('Include video thumbnail URL in template')
      .addToggle(toggle => toggle
        .setValue(this.plugin.settings.includeThumbnailUrl)
        .onChange(async (value) => {
          this.plugin.settings.includeThumbnailUrl = value;
          await this.plugin.saveSettings();
        }));
  }

  private addLLMSettings(containerEl: HTMLElement): void {
    containerEl.createEl('h3', { text: 'LLM Configuration' });

    new Setting(containerEl)
      .setName('LLM Provider')
      .setDesc('Select your local LLM provider')
      .addDropdown(dropdown => dropdown
        .addOption('ollama', 'Ollama')
        .addOption('lmstudio', 'LM Studio')
        .addOption('llamacpp', 'llama.cpp')
        .addOption('custom', 'Custom')
        .setValue(this.plugin.settings.llmProvider)
        .onChange(async (value) => {
          this.plugin.settings.llmProvider = value as any;
          await this.plugin.saveSettings();
          this.display();
        }));

    new Setting(containerEl)
      .setName('Auto-detect endpoint')
      .setDesc('Automatically detect LLM endpoint')
      .addToggle(toggle => toggle
        .setValue(this.plugin.settings.autoDetectEndpoint)
        .onChange(async (value) => {
          this.plugin.settings.autoDetectEndpoint = value;
          await this.plugin.saveSettings();
        }));

    new Setting(containerEl)
      .setName('LLM Endpoint')
      .setDesc('Custom endpoint URL for LLM')
      .addText(text => text
        .setPlaceholder('http://localhost:11434/api/generate')
        .setValue(this.plugin.settings.llmEndpoint)
        .onChange(async (value) => {
          this.plugin.settings.llmEndpoint = value;
          await this.plugin.saveSettings();
        }));

    new Setting(containerEl)
      .setName('Model name')
      .setDesc('LLM model name to use')
      .addText(text => text
        .setPlaceholder('llama2')
        .setValue(this.plugin.settings.llmModel)
        .onChange(async (value) => {
          this.plugin.settings.llmModel = value;
          await this.plugin.saveSettings();
        }));

    new Setting(containerEl)
      .setName('Custom system prompt')
      .setDesc('Customize the prompt sent to the LLM')
      .addTextArea(text => text
        .setPlaceholder('Summarize the following transcript...')
        .setValue(this.plugin.settings.customSystemPrompt)
        .onChange(async (value) => {
          this.plugin.settings.customSystemPrompt = value;
          await this.plugin.saveSettings();
        }));

    containerEl.createEl('h4', { text: 'LLM Output Options' });

    new Setting(containerEl)
      .setName('Generate summary')
      .addToggle(toggle => toggle
        .setValue(this.plugin.settings.outputSummary)
        .onChange(async (value) => {
          this.plugin.settings.outputSummary = value;
          await this.plugin.saveSettings();
        }));

    new Setting(containerEl)
      .setName('Generate key points')
      .addToggle(toggle => toggle
        .setValue(this.plugin.settings.outputKeyPoints)
        .onChange(async (value) => {
          this.plugin.settings.outputKeyPoints = value;
          await this.plugin.saveSettings();
        }));

    new Setting(containerEl)
      .setName('Generate tags')
      .addToggle(toggle => toggle
        .setValue(this.plugin.settings.outputTags)
        .onChange(async (value) => {
          this.plugin.settings.outputTags = value;
          await this.plugin.saveSettings();
        }));

    new Setting(containerEl)
      .setName('Generate questions')
      .addToggle(toggle => toggle
        .setValue(this.plugin.settings.outputQuestions)
        .onChange(async (value) => {
          this.plugin.settings.outputQuestions = value;
          await this.plugin.saveSettings();
        }));

    new Setting(containerEl)
      .setName('Request timeout (ms)')
      .setDesc('Timeout for LLM requests in milliseconds')
      .addText(text => text
        .setPlaceholder('30000')
        .setValue(String(this.plugin.settings.requestTimeout))
        .onChange(async (value) => {
          const num = parseInt(value);
          if (!isNaN(num)) {
            this.plugin.settings.requestTimeout = num;
            await this.plugin.saveSettings();
          }
        }));
  }

  private addErrorHandlingSettings(containerEl: HTMLElement): void {
    containerEl.createEl('h3', { text: 'Error Handling' });

    new Setting(containerEl)
      .setName('Error behavior')
      .setDesc('How to handle errors during extraction')
      .addDropdown(dropdown => dropdown
        .addOption('stop', 'Stop on error (don\'t create file)')
        .addOption('partial', 'Save partial data')
        .addOption('skip', 'Skip failed steps with warning')
        .setValue(this.plugin.settings.errorBehavior)
        .onChange(async (value) => {
          this.plugin.settings.errorBehavior = value as 'stop' | 'partial' | 'skip';
          await this.plugin.saveSettings();
        }));
  }
}
```

**Step 2: Register settings tab in main.ts**

Modify `src/main.ts`:

```typescript
import { Plugin } from 'obsidian';
import { YTExtractSettings, DEFAULT_SETTINGS } from './models/types';
import { YTExtractSettingTab } from './ui/settings-tab';

export default class YTExtractPlugin extends Plugin {
  settings: YTExtractSettings;

  async onload() {
    console.log('Loading YouTube Transcript Extractor plugin');

    await this.loadSettings();

    // Add settings tab
    this.addSettingTab(new YTExtractSettingTab(this.app, this));
  }

  async onunload() {
    console.log('Unloading YouTube Transcript Extractor plugin');
  }

  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }

  async saveSettings() {
    await this.saveData(this.settings);
  }
}
```

**Step 3: Test the build**

Run: `npm run build`
Expected: Build succeeds

**Step 4: Commit**

```bash
git add src/ui/settings-tab.ts src/main.ts
git commit -m "feat: add settings tab UI"
```

---

## Task 5: YouTube Service - URL Parsing

**Files:**
- Create: `src/services/youtube.ts`

**Step 1: Write URL validation and parsing**

```typescript
import { TranscriptSegment, VideoMetadata, YouTubeData } from '../models/types';

export class YouTubeService {
  /**
   * Extract video ID from various YouTube URL formats
   */
  extractVideoId(url: string): string | null {
    const patterns = [
      /(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/)([a-zA-Z0-9_-]{11})/,
      /youtube\.com\/watch\?.*v=([a-zA-Z0-9_-]{11})/
    ];

    for (const pattern of patterns) {
      const match = url.match(pattern);
      if (match && match[1]) {
        return match[1];
      }
    }

    return null;
  }

  /**
   * Validate if string is a valid YouTube URL
   */
  isValidYouTubeUrl(url: string): boolean {
    return this.extractVideoId(url) !== null;
  }
}
```

**Step 2: Write test for URL parsing**

Create: `src/services/__tests__/youtube.test.ts`

```typescript
import { YouTubeService } from '../youtube';

describe('YouTubeService', () => {
  let service: YouTubeService;

  beforeEach(() => {
    service = new YouTubeService();
  });

  describe('extractVideoId', () => {
    it('should extract ID from standard watch URL', () => {
      const id = service.extractVideoId('https://www.youtube.com/watch?v=dQw4w9WgXcQ');
      expect(id).toBe('dQw4w9WgXcQ');
    });

    it('should extract ID from short URL', () => {
      const id = service.extractVideoId('https://youtu.be/dQw4w9WgXcQ');
      expect(id).toBe('dQw4w9WgXcQ');
    });

    it('should extract ID from embed URL', () => {
      const id = service.extractVideoId('https://www.youtube.com/embed/dQw4w9WgXcQ');
      expect(id).toBe('dQw4w9WgXcQ');
    });

    it('should return null for invalid URL', () => {
      const id = service.extractVideoId('https://example.com');
      expect(id).toBeNull();
    });
  });

  describe('isValidYouTubeUrl', () => {
    it('should return true for valid URL', () => {
      expect(service.isValidYouTubeUrl('https://www.youtube.com/watch?v=dQw4w9WgXcQ')).toBe(true);
    });

    it('should return false for invalid URL', () => {
      expect(service.isValidYouTubeUrl('https://example.com')).toBe(false);
    });
  });
});
```

**Step 3: Commit**

```bash
git add src/services/youtube.ts
git commit -m "feat: add YouTube URL parsing and validation"
```

---

## Task 6: YouTube Service - Transcript Extraction

**Files:**
- Modify: `src/services/youtube.ts`

**Step 1: Add transcript extraction method**

Add to `src/services/youtube.ts`:

```typescript
import { YoutubeTranscript } from 'youtube-transcript';

export class YouTubeService {
  // ... existing methods ...

  /**
   * Fetch transcript for a video
   */
  async fetchTranscript(videoId: string): Promise<{
    plain: string;
    timestamped: TranscriptSegment[]
  }> {
    try {
      const transcript = await YoutubeTranscript.fetchTranscript(videoId);

      const timestamped: TranscriptSegment[] = transcript.map(item => ({
        text: item.text,
        offset: item.offset,
        duration: item.duration
      }));

      const plain = transcript.map(item => item.text).join(' ');

      return { plain, timestamped };
    } catch (error) {
      throw new Error(`Failed to fetch transcript: ${error.message}`);
    }
  }

  /**
   * Format timestamped transcript for display
   */
  formatTimestampedTranscript(segments: TranscriptSegment[]): string {
    return segments.map(segment => {
      const timestamp = this.formatTimestamp(segment.offset);
      return `[${timestamp}] ${segment.text}`;
    }).join('\n');
  }

  /**
   * Convert milliseconds to MM:SS or HH:MM:SS format
   */
  private formatTimestamp(ms: number): string {
    const seconds = Math.floor(ms / 1000);
    const minutes = Math.floor(seconds / 60);
    const hours = Math.floor(minutes / 60);

    const sec = String(seconds % 60).padStart(2, '0');
    const min = String(minutes % 60).padStart(2, '0');

    if (hours > 0) {
      const hr = String(hours).padStart(2, '0');
      return `${hr}:${min}:${sec}`;
    }

    return `${min}:${sec}`;
  }
}
```

**Step 2: Commit**

```bash
git add src/services/youtube.ts
git commit -m "feat: add transcript extraction and formatting"
```

---

## Task 7: YouTube Service - Metadata Extraction

**Files:**
- Modify: `src/services/youtube.ts`

**Step 1: Add metadata extraction method**

Add to `src/services/youtube.ts`:

```typescript
import ytdl from 'ytdl-core';

export class YouTubeService {
  // ... existing methods ...

  /**
   * Fetch video metadata
   */
  async fetchMetadata(videoId: string): Promise<VideoMetadata> {
    try {
      const url = `https://www.youtube.com/watch?v=${videoId}`;
      const info = await ytdl.getInfo(url);

      const videoDetails = info.videoDetails;

      return {
        title: videoDetails.title,
        url: url,
        videoId: videoId,
        channel: videoDetails.author.name,
        uploadDate: videoDetails.publishDate,
        duration: this.formatDuration(parseInt(videoDetails.lengthSeconds)),
        viewCount: parseInt(videoDetails.viewCount),
        description: videoDetails.description || '',
        channelUrl: videoDetails.author.channel_url,
        thumbnailUrl: videoDetails.thumbnails[0]?.url || ''
      };
    } catch (error) {
      throw new Error(`Failed to fetch metadata: ${error.message}`);
    }
  }

  /**
   * Format duration from seconds to readable format
   */
  private formatDuration(seconds: number): string {
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    const secs = seconds % 60;

    if (hours > 0) {
      return `${hours}h ${minutes}m ${secs}s`;
    } else if (minutes > 0) {
      return `${minutes}m ${secs}s`;
    } else {
      return `${secs}s`;
    }
  }
}
```

**Step 2: Commit**

```bash
git add src/services/youtube.ts
git commit -m "feat: add video metadata extraction"
```

---

## Task 8: YouTube Service - Complete Integration

**Files:**
- Modify: `src/services/youtube.ts`

**Step 1: Add main extraction method**

Add to `src/services/youtube.ts`:

```typescript
export class YouTubeService {
  // ... existing methods ...

  /**
   * Extract all data for a YouTube video
   */
  async extractVideo(url: string): Promise<YouTubeData> {
    const videoId = this.extractVideoId(url);

    if (!videoId) {
      throw new Error('Invalid YouTube URL');
    }

    const [metadata, { plain, timestamped }] = await Promise.all([
      this.fetchMetadata(videoId),
      this.fetchTranscript(videoId)
    ]);

    return {
      metadata,
      transcript: plain,
      timestampedTranscript: timestamped
    };
  }

  /**
   * Extract with retry logic
   */
  async extractVideoWithRetry(url: string, maxRetries = 3): Promise<YouTubeData> {
    let lastError: Error;

    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        return await this.extractVideo(url);
      } catch (error) {
        lastError = error;

        if (attempt < maxRetries) {
          const delay = Math.pow(2, attempt) * 1000;
          await new Promise(resolve => setTimeout(resolve, delay));
        }
      }
    }

    throw lastError;
  }
}
```

**Step 2: Commit**

```bash
git add src/services/youtube.ts
git commit -m "feat: add main extraction method with retry logic"
```

---

## Task 9: LLM Provider Base Classes

**Files:**
- Create: `src/models/providers.ts`

**Step 1: Write base LLM provider interface implementation**

```typescript
import { LLMProvider, LLMResponse, YTExtractSettings } from './types';

export abstract class BaseLLMProvider implements LLMProvider {
  abstract name: string;
  abstract defaultEndpoint: string;

  constructor(protected settings: YTExtractSettings) {}

  abstract testConnection(): Promise<boolean>;
  abstract generateSummary(transcript: string, prompt: string): Promise<LLMResponse>;

  /**
   * Make HTTP request with timeout
   */
  protected async fetchWithTimeout(
    url: string,
    options: RequestInit,
    timeout: number
  ): Promise<Response> {
    const controller = new AbortController();
    const id = setTimeout(() => controller.abort(), timeout);

    try {
      const response = await fetch(url, {
        ...options,
        signal: controller.signal
      });
      clearTimeout(id);
      return response;
    } catch (error) {
      clearTimeout(id);
      throw error;
    }
  }

  /**
   * Parse LLM response based on requested outputs
   */
  protected parseLLMOutput(rawResponse: string): LLMResponse {
    const response: LLMResponse = {};

    if (this.settings.outputSummary) {
      response.summary = this.extractSection(rawResponse, 'summary');
    }

    if (this.settings.outputKeyPoints) {
      response.keyPoints = this.extractListItems(rawResponse, 'key points');
    }

    if (this.settings.outputTags) {
      response.tags = this.extractListItems(rawResponse, 'tags');
    }

    if (this.settings.outputQuestions) {
      response.questions = this.extractListItems(rawResponse, 'questions');
    }

    return response;
  }

  private extractSection(text: string, sectionName: string): string {
    const regex = new RegExp(`${sectionName}:?\\s*(.+?)(?=\\n\\n|$)`, 'is');
    const match = text.match(regex);
    return match ? match[1].trim() : '';
  }

  private extractListItems(text: string, sectionName: string): string[] {
    const regex = new RegExp(`${sectionName}:?\\s*([\\s\\S]+?)(?=\\n\\n|$)`, 'i');
    const match = text.match(regex);

    if (!match) return [];

    return match[1]
      .split('\n')
      .map(line => line.replace(/^[-*•]\s*/, '').trim())
      .filter(line => line.length > 0);
  }
}
```

**Step 2: Commit**

```bash
git add src/models/providers.ts
git commit -m "feat: add base LLM provider class"
```

---

## Task 10: Ollama Provider Implementation

**Files:**
- Modify: `src/models/providers.ts`

**Step 1: Add Ollama provider class**

Add to `src/models/providers.ts`:

```typescript
export class OllamaProvider extends BaseLLMProvider {
  name = 'Ollama';
  defaultEndpoint = 'http://localhost:11434/api/generate';

  async testConnection(): Promise<boolean> {
    try {
      const response = await this.fetchWithTimeout(
        this.defaultEndpoint.replace('/api/generate', '/api/tags'),
        { method: 'GET' },
        5000
      );
      return response.ok;
    } catch {
      return false;
    }
  }

  async generateSummary(transcript: string, prompt: string): Promise<LLMResponse> {
    const endpoint = this.settings.autoDetectEndpoint
      ? this.defaultEndpoint
      : this.settings.llmEndpoint;

    const requestBody = {
      model: this.settings.llmModel,
      prompt: this.buildPrompt(transcript, prompt),
      stream: false
    };

    try {
      const response = await this.fetchWithTimeout(
        endpoint,
        {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(requestBody)
        },
        this.settings.requestTimeout
      );

      if (!response.ok) {
        throw new Error(`Ollama request failed: ${response.statusText}`);
      }

      const data = await response.json();
      return this.parseLLMOutput(data.response);
    } catch (error) {
      throw new Error(`Ollama generation failed: ${error.message}`);
    }
  }

  private buildPrompt(transcript: string, systemPrompt: string): string {
    let prompt = `${systemPrompt}\n\nTranscript:\n${transcript}\n\n`;

    const outputs = [];
    if (this.settings.outputSummary) outputs.push('summary');
    if (this.settings.outputKeyPoints) outputs.push('key points');
    if (this.settings.outputTags) outputs.push('tags');
    if (this.settings.outputQuestions) outputs.push('questions');

    prompt += `Please provide: ${outputs.join(', ')}`;
    return prompt;
  }
}
```

**Step 2: Commit**

```bash
git add src/models/providers.ts
git commit -m "feat: add Ollama provider implementation"
```

---

## Task 11: LM Studio Provider Implementation

**Files:**
- Modify: `src/models/providers.ts`

**Step 1: Add LM Studio provider class**

Add to `src/models/providers.ts`:

```typescript
export class LMStudioProvider extends BaseLLMProvider {
  name = 'LM Studio';
  defaultEndpoint = 'http://localhost:1234/v1/chat/completions';

  async testConnection(): Promise<boolean> {
    try {
      const response = await this.fetchWithTimeout(
        this.defaultEndpoint.replace('/v1/chat/completions', '/v1/models'),
        { method: 'GET' },
        5000
      );
      return response.ok;
    } catch {
      return false;
    }
  }

  async generateSummary(transcript: string, prompt: string): Promise<LLMResponse> {
    const endpoint = this.settings.autoDetectEndpoint
      ? this.defaultEndpoint
      : this.settings.llmEndpoint;

    const requestBody = {
      model: this.settings.llmModel,
      messages: [
        { role: 'system', content: prompt },
        { role: 'user', content: this.buildUserPrompt(transcript) }
      ],
      temperature: 0.7
    };

    try {
      const response = await this.fetchWithTimeout(
        endpoint,
        {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(requestBody)
        },
        this.settings.requestTimeout
      );

      if (!response.ok) {
        throw new Error(`LM Studio request failed: ${response.statusText}`);
      }

      const data = await response.json();
      const content = data.choices[0].message.content;
      return this.parseLLMOutput(content);
    } catch (error) {
      throw new Error(`LM Studio generation failed: ${error.message}`);
    }
  }

  private buildUserPrompt(transcript: string): string {
    const outputs = [];
    if (this.settings.outputSummary) outputs.push('summary');
    if (this.settings.outputKeyPoints) outputs.push('key points');
    if (this.settings.outputTags) outputs.push('tags');
    if (this.settings.outputQuestions) outputs.push('questions');

    return `Transcript:\n${transcript}\n\nPlease provide: ${outputs.join(', ')}`;
  }
}
```

**Step 2: Commit**

```bash
git add src/models/providers.ts
git commit -m "feat: add LM Studio provider implementation"
```

---

## Task 12: llama.cpp Provider Implementation

**Files:**
- Modify: `src/models/providers.ts`

**Step 1: Add llama.cpp provider class**

Add to `src/models/providers.ts`:

```typescript
export class LlamaCppProvider extends BaseLLMProvider {
  name = 'llama.cpp';
  defaultEndpoint = 'http://localhost:8080/completion';

  async testConnection(): Promise<boolean> {
    try {
      const response = await this.fetchWithTimeout(
        this.defaultEndpoint.replace('/completion', '/health'),
        { method: 'GET' },
        5000
      );
      return response.ok;
    } catch {
      return false;
    }
  }

  async generateSummary(transcript: string, prompt: string): Promise<LLMResponse> {
    const endpoint = this.settings.autoDetectEndpoint
      ? this.defaultEndpoint
      : this.settings.llmEndpoint;

    const requestBody = {
      prompt: this.buildPrompt(transcript, prompt),
      n_predict: 512,
      temperature: 0.7,
      stop: ['</s>', '\n\n\n']
    };

    try {
      const response = await this.fetchWithTimeout(
        endpoint,
        {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(requestBody)
        },
        this.settings.requestTimeout
      );

      if (!response.ok) {
        throw new Error(`llama.cpp request failed: ${response.statusText}`);
      }

      const data = await response.json();
      return this.parseLLMOutput(data.content);
    } catch (error) {
      throw new Error(`llama.cpp generation failed: ${error.message}`);
    }
  }

  private buildPrompt(transcript: string, systemPrompt: string): string {
    const outputs = [];
    if (this.settings.outputSummary) outputs.push('summary');
    if (this.settings.outputKeyPoints) outputs.push('key points');
    if (this.settings.outputTags) outputs.push('tags');
    if (this.settings.outputQuestions) outputs.push('questions');

    return `${systemPrompt}\n\nTranscript:\n${transcript}\n\nPlease provide: ${outputs.join(', ')}`;
  }
}
```

**Step 2: Commit**

```bash
git add src/models/providers.ts
git commit -m "feat: add llama.cpp provider implementation"
```

---

## Task 13: LLM Service with Auto-detection

**Files:**
- Create: `src/services/llm.ts`

**Step 1: Write LLM service class**

```typescript
import { LLMProvider, LLMResponse, YTExtractSettings } from '../models/types';
import { OllamaProvider, LMStudioProvider, LlamaCppProvider } from '../models/providers';

export class LLMService {
  private provider: LLMProvider;

  constructor(private settings: YTExtractSettings) {
    this.provider = this.createProvider();
  }

  private createProvider(): LLMProvider {
    switch (this.settings.llmProvider) {
      case 'ollama':
        return new OllamaProvider(this.settings);
      case 'lmstudio':
        return new LMStudioProvider(this.settings);
      case 'llamacpp':
        return new LlamaCppProvider(this.settings);
      default:
        return new OllamaProvider(this.settings);
    }
  }

  /**
   * Auto-detect available LLM provider
   */
  async autoDetect(): Promise<LLMProvider | null> {
    const providers = [
      new OllamaProvider(this.settings),
      new LMStudioProvider(this.settings),
      new LlamaCppProvider(this.settings)
    ];

    for (const provider of providers) {
      try {
        const isAvailable = await provider.testConnection();
        if (isAvailable) {
          return provider;
        }
      } catch {
        continue;
      }
    }

    return null;
  }

  /**
   * Test current provider connection
   */
  async testConnection(): Promise<boolean> {
    try {
      return await this.provider.testConnection();
    } catch {
      return false;
    }
  }

  /**
   * Generate summary and other outputs
   */
  async generateSummary(transcript: string): Promise<LLMResponse> {
    if (this.settings.autoDetectEndpoint) {
      const detectedProvider = await this.autoDetect();
      if (detectedProvider) {
        this.provider = detectedProvider;
      }
    }

    return await this.provider.generateSummary(
      transcript,
      this.settings.customSystemPrompt
    );
  }
}
```

**Step 2: Commit**

```bash
git add src/services/llm.ts
git commit -m "feat: add LLM service with auto-detection"
```

---

## Task 14: Template Service

**Files:**
- Create: `src/services/template.ts`

**Step 1: Write template service class**

```typescript
import { App, TFile } from 'obsidian';
import { TemplateData, YouTubeData, LLMResponse, YTExtractSettings } from '../models/types';
import { YouTubeService } from './youtube';

export class TemplateService {
  private youtubeService: YouTubeService;

  constructor(
    private app: App,
    private settings: YTExtractSettings
  ) {
    this.youtubeService = new YouTubeService();
  }

  /**
   * Build template data from YouTube data and LLM response
   */
  buildTemplateData(
    youtubeData: YouTubeData,
    llmResponse: LLMResponse
  ): TemplateData {
    const { metadata, transcript, timestampedTranscript } = youtubeData;

    return {
      // Video metadata
      title: metadata.title,
      url: metadata.url,
      channel: metadata.channel,
      upload_date: this.settings.includeUploadDate ? (metadata.uploadDate || '') : '',
      duration: this.settings.includeDuration ? (metadata.duration || '') : '',
      view_count: this.settings.includeViewCount ? String(metadata.viewCount || '') : '',
      description: this.settings.includeDescription ? (metadata.description || '') : '',
      channel_url: this.settings.includeChannelUrl ? (metadata.channelUrl || '') : '',
      thumbnail_url: this.settings.includeThumbnailUrl ? (metadata.thumbnailUrl || '') : '',

      // LLM outputs
      llm_summary: llmResponse.summary || '',
      llm_key_points: this.formatKeyPoints(llmResponse.keyPoints),
      generated_tags: this.formatTags(llmResponse.tags),
      llm_questions: this.formatQuestions(llmResponse.questions),

      // Transcript
      transcript: transcript,
      transcript_timestamped: timestampedTranscript
        ? this.youtubeService.formatTimestampedTranscript(timestampedTranscript)
        : '',

      // Other
      extraction_date: new Date().toISOString().split('T')[0]
    };
  }

  /**
   * Process template with data
   */
  async processTemplate(data: TemplateData): Promise<string> {
    let template: string;

    if (this.settings.templatePath) {
      template = await this.loadCustomTemplate();
    } else {
      template = await this.loadDefaultTemplate();
    }

    return this.replaceVariables(template, data);
  }

  /**
   * Load custom template from vault
   */
  private async loadCustomTemplate(): Promise<string> {
    const file = this.app.vault.getAbstractFileByPath(this.settings.templatePath);

    if (!file || !(file instanceof TFile)) {
      throw new Error('Custom template file not found');
    }

    return await this.app.vault.read(file);
  }

  /**
   * Load default template
   */
  private async loadDefaultTemplate(): Promise<string> {
    return `---
title: {{title}}
url: {{url}}
channel: {{channel}}
date: {{upload_date}}
duration: {{duration}}
tags: {{generated_tags}}
---

# {{title}}

## Summary
{{llm_summary}}

---

## Key Points
{{llm_key_points}}

---

## Personal Notes

---

## Transcript
{{transcript}}`;
  }

  /**
   * Replace template variables with actual data
   */
  private replaceVariables(template: string, data: TemplateData): string {
    let result = template;

    for (const [key, value] of Object.entries(data)) {
      const regex = new RegExp(`{{${key}}}`, 'g');
      result = result.replace(regex, value);
    }

    return result;
  }

  /**
   * Format key points as bullet list
   */
  private formatKeyPoints(points: string[] | undefined): string {
    if (!points || points.length === 0) return '';
    return points.map(point => `- ${point}`).join('\n');
  }

  /**
   * Format tags as comma-separated list
   */
  private formatTags(tags: string[] | undefined): string {
    if (!tags || tags.length === 0) return '';
    return tags.join(', ');
  }

  /**
   * Format questions as numbered list
   */
  private formatQuestions(questions: string[] | undefined): string {
    if (!questions || questions.length === 0) return '';
    return questions.map((q, i) => `${i + 1}. ${q}`).join('\n');
  }

  /**
   * Generate filename from template
   */
  generateFilename(data: TemplateData): string {
    let filename = this.settings.namingPattern;

    filename = filename.replace('{date}', data.extraction_date);
    filename = filename.replace('{title}', this.sanitizeFilename(data.title));
    filename = filename.replace('{channel}', this.sanitizeFilename(data.channel));
    filename = filename.replace('{id}', data.url.split('v=')[1] || '');

    return `${filename}.md`;
  }

  /**
   * Sanitize filename by removing invalid characters
   */
  private sanitizeFilename(name: string): string {
    return name.replace(/[\\/:*?"<>|]/g, '-').substring(0, 100);
  }

  /**
   * Get full file path with folder
   */
  getFilePath(filename: string): string {
    const folder = this.settings.defaultFolder;
    return folder ? `${folder}/${filename}` : filename;
  }

  /**
   * Handle file name conflicts
   */
  async resolveFileNameConflict(path: string): Promise<string> {
    const file = this.app.vault.getAbstractFileByPath(path);

    if (!file) {
      return path;
    }

    if (this.settings.fileExistsBehavior === 'append') {
      let counter = 1;
      let newPath = path;

      while (this.app.vault.getAbstractFileByPath(newPath)) {
        const pathWithoutExt = path.replace('.md', '');
        newPath = `${pathWithoutExt} ${counter}.md`;
        counter++;
      }

      return newPath;
    }

    return path;
  }
}
```

**Step 2: Commit**

```bash
git add src/services/template.ts
git commit -m "feat: add template service"
```

---

## Task 15: URL Input Modal

**Files:**
- Create: `src/ui/url-modal.ts`

**Step 1: Write URL input modal class**

```typescript
import { App, Modal, Notice, Setting } from 'obsidian';
import { YouTubeService } from '../services/youtube';

export class URLInputModal extends Modal {
  private url: string = '';
  private onSubmit: (url: string) => void;
  private youtubeService: YouTubeService;

  constructor(app: App, onSubmit: (url: string) => void, initialUrl?: string) {
    super(app);
    this.onSubmit = onSubmit;
    this.youtubeService = new YouTubeService();
    if (initialUrl) {
      this.url = initialUrl;
    }
  }

  onOpen() {
    const { contentEl } = this;
    contentEl.empty();

    contentEl.createEl('h2', { text: 'Extract YouTube Video' });

    new Setting(contentEl)
      .setName('YouTube URL')
      .setDesc('Enter the YouTube video URL')
      .addText(text => {
        text
          .setPlaceholder('https://www.youtube.com/watch?v=...')
          .setValue(this.url)
          .onChange(value => {
            this.url = value;
          });

        // Auto-focus and select text
        setTimeout(() => {
          text.inputEl.focus();
          text.inputEl.select();
        }, 10);

        // Handle Enter key
        text.inputEl.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') {
            e.preventDefault();
            this.handleSubmit();
          }
        });
      });

    const buttonContainer = contentEl.createDiv({ cls: 'modal-button-container' });

    buttonContainer.createEl('button', { text: 'Cancel' }, (btn) => {
      btn.addEventListener('click', () => this.close());
    });

    buttonContainer.createEl('button', {
      text: 'Extract',
      cls: 'mod-cta'
    }, (btn) => {
      btn.addEventListener('click', () => this.handleSubmit());
    });
  }

  private handleSubmit() {
    if (!this.url.trim()) {
      new Notice('Please enter a YouTube URL');
      return;
    }

    if (!this.youtubeService.isValidYouTubeUrl(this.url)) {
      new Notice('Invalid YouTube URL');
      return;
    }

    this.close();
    this.onSubmit(this.url);
  }

  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
}
```

**Step 2: Add CSS for modal buttons**

Create: `styles.css`

```css
.modal-button-container {
  display: flex;
  justify-content: flex-end;
  gap: 8px;
  margin-top: 20px;
}

.modal-button-container button {
  padding: 6px 16px;
  border-radius: 4px;
  cursor: pointer;
}
```

**Step 3: Commit**

```bash
git add src/ui/url-modal.ts styles.css
git commit -m "feat: add URL input modal"
```

---

## Task 16: Status Bar Integration

**Files:**
- Create: `src/ui/status-bar.ts`

**Step 1: Write status bar manager class**

```typescript
import { Plugin } from 'obsidian';

export class StatusBarManager {
  private statusBarItem: HTMLElement;
  private currentMessage: string = '';

  constructor(private plugin: Plugin) {
    this.statusBarItem = this.plugin.addStatusBarItem();
  }

  /**
   * Show status message
   */
  show(message: string) {
    this.currentMessage = message;
    this.statusBarItem.setText(message);
    this.statusBarItem.style.display = 'inline-block';
  }

  /**
   * Update current message
   */
  update(message: string) {
    this.show(message);
  }

  /**
   * Clear status message
   */
  clear() {
    this.currentMessage = '';
    this.statusBarItem.setText('');
    this.statusBarItem.style.display = 'none';
  }

  /**
   * Show success message and auto-clear
   */
  showSuccess(message: string, duration: number = 3000) {
    this.show(`✓ ${message}`);
    setTimeout(() => this.clear(), duration);
  }

  /**
   * Show error message and auto-clear
   */
  showError(message: string, duration: number = 5000) {
    this.show(`✗ ${message}`);
    setTimeout(() => this.clear(), duration);
  }

  /**
   * Get current message
   */
  getCurrentMessage(): string {
    return this.currentMessage;
  }
}
```

**Step 2: Commit**

```bash
git add src/ui/status-bar.ts
git commit -m "feat: add status bar manager"
```

---

## Task 17: Main Extraction Pipeline

**Files:**
- Create: `src/services/extraction.ts`

**Step 1: Write extraction orchestrator**

```typescript
import { App, Notice } from 'obsidian';
import { YouTubeService } from './youtube';
import { LLMService } from './llm';
import { TemplateService } from './template';
import { YTExtractSettings } from '../models/types';
import { StatusBarManager } from '../ui/status-bar';

export class ExtractionService {
  private youtubeService: YouTubeService;
  private llmService: LLMService;
  private templateService: TemplateService;

  constructor(
    private app: App,
    private settings: YTExtractSettings,
    private statusBar: StatusBarManager
  ) {
    this.youtubeService = new YouTubeService();
    this.llmService = new LLMService(settings);
    this.templateService = new TemplateService(app, settings);
  }

  /**
   * Main extraction pipeline
   */
  async extract(url: string): Promise<void> {
    try {
      // Step 1: Fetch YouTube data
      this.statusBar.show('Fetching transcript...');
      const youtubeData = await this.youtubeService.extractVideoWithRetry(url);

      // Step 2: Generate LLM summary
      let llmResponse;
      try {
        this.statusBar.update('Generating summary...');
        llmResponse = await this.llmService.generateSummary(youtubeData.transcript);
      } catch (error) {
        llmResponse = await this.handleLLMError(error);
      }

      // Step 3: Process template
      this.statusBar.update('Saving note...');
      const templateData = this.templateService.buildTemplateData(youtubeData, llmResponse);
      const content = await this.templateService.processTemplate(templateData);

      // Step 4: Save file
      const filename = this.templateService.generateFilename(templateData);
      const filepath = this.templateService.getFilePath(filename);
      const finalPath = await this.templateService.resolveFileNameConflict(filepath);

      await this.saveFile(finalPath, content);

      // Success
      this.statusBar.showSuccess('Note created successfully');
      new Notice(`Created: ${finalPath}`);

    } catch (error) {
      this.handleError(error);
    }
  }

  /**
   * Handle LLM errors based on settings
   */
  private async handleLLMError(error: Error): Promise<any> {
    const behavior = this.settings.errorBehavior;

    if (behavior === 'stop') {
      throw new Error(`LLM generation failed: ${error.message}`);
    }

    if (behavior === 'partial' || behavior === 'skip') {
      new Notice('Warning: LLM unavailable, creating note without summary');
      return {
        summary: behavior === 'skip' ? 'LLM unavailable' : '',
        keyPoints: [],
        tags: [],
        questions: []
      };
    }

    return {
      summary: '',
      keyPoints: [],
      tags: [],
      questions: []
    };
  }

  /**
   * Save file to vault
   */
  private async saveFile(path: string, content: string): Promise<void> {
    const folderPath = path.substring(0, path.lastIndexOf('/'));

    if (folderPath && !this.app.vault.getAbstractFileByPath(folderPath)) {
      await this.app.vault.createFolder(folderPath);
    }

    await this.app.vault.create(path, content);
  }

  /**
   * Handle extraction errors
   */
  private handleError(error: Error) {
    console.error('Extraction error:', error);
    this.statusBar.showError('Extraction failed');
    new Notice(`Error: ${error.message}`);
  }
}
```

**Step 2: Commit**

```bash
git add src/services/extraction.ts
git commit -m "feat: add extraction orchestration service"
```

---

## Task 18: Wire Up Command Palette

**Files:**
- Modify: `src/main.ts`

**Step 1: Import required services**

Modify `src/main.ts`:

```typescript
import { Plugin } from 'obsidian';
import { YTExtractSettings, DEFAULT_SETTINGS } from './models/types';
import { YTExtractSettingTab } from './ui/settings-tab';
import { URLInputModal } from './ui/url-modal';
import { StatusBarManager } from './ui/status-bar';
import { ExtractionService } from './services/extraction';

export default class YTExtractPlugin extends Plugin {
  settings: YTExtractSettings;
  statusBar: StatusBarManager;

  async onload() {
    console.log('Loading YouTube Transcript Extractor plugin');

    await this.loadSettings();

    // Initialize status bar
    this.statusBar = new StatusBarManager(this);

    // Add settings tab
    this.addSettingTab(new YTExtractSettingTab(this.app, this));

    // Add command palette command
    this.addCommand({
      id: 'extract-youtube-video',
      name: 'Extract YouTube Video',
      callback: () => {
        this.openURLModal();
      }
    });
  }

  async onunload() {
    console.log('Unloading YouTube Transcript Extractor plugin');
  }

  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }

  async saveSettings() {
    await this.saveData(this.settings);
  }

  private openURLModal(initialUrl?: string) {
    new URLInputModal(this.app, async (url) => {
      const extraction = new ExtractionService(this.app, this.settings, this.statusBar);
      await extraction.extract(url);
    }, initialUrl).open();
  }
}
```

**Step 2: Test the build**

Run: `npm run build`
Expected: Build succeeds

**Step 3: Commit**

```bash
git add src/main.ts
git commit -m "feat: wire up command palette integration"
```

---

## Task 19: Add Ribbon Icon

**Files:**
- Modify: `src/main.ts`

**Step 1: Add ribbon icon**

Modify the `onload` method in `src/main.ts`:

```typescript
async onload() {
  console.log('Loading YouTube Transcript Extractor plugin');

  await this.loadSettings();

  // Initialize status bar
  this.statusBar = new StatusBarManager(this);

  // Add settings tab
  this.addSettingTab(new YTExtractSettingTab(this.app, this));

  // Add ribbon icon
  this.addRibbonIcon('youtube', 'Extract YouTube Video', () => {
    this.openURLModal();
  });

  // Add command palette command
  this.addCommand({
    id: 'extract-youtube-video',
    name: 'Extract YouTube Video',
    callback: () => {
      this.openURLModal();
    }
  });
}
```

**Step 2: Commit**

```bash
git add src/main.ts
git commit -m "feat: add ribbon icon"
```

---

## Task 20: Add Context Menu

**Files:**
- Modify: `src/main.ts`

**Step 1: Add context menu for selected text**

Modify the `onload` method in `src/main.ts`:

```typescript
async onload() {
  console.log('Loading YouTube Transcript Extractor plugin');

  await this.loadSettings();

  // Initialize status bar
  this.statusBar = new StatusBarManager(this);

  // Add settings tab
  this.addSettingTab(new YTExtractSettingTab(this.app, this));

  // Add ribbon icon
  this.addRibbonIcon('youtube', 'Extract YouTube Video', () => {
    this.openURLModal();
  });

  // Add command palette command
  this.addCommand({
    id: 'extract-youtube-video',
    name: 'Extract YouTube Video',
    callback: () => {
      this.openURLModal();
    }
  });

  // Add editor context menu
  this.registerEvent(
    this.app.workspace.on('editor-menu', (menu, editor) => {
      const selection = editor.getSelection();

      if (selection && this.looksLikeYouTubeURL(selection)) {
        menu.addItem((item) => {
          item
            .setTitle('Extract YouTube Video')
            .setIcon('youtube')
            .onClick(() => {
              this.openURLModal(selection.trim());
            });
        });
      }
    })
  );
}

private looksLikeYouTubeURL(text: string): boolean {
  return text.includes('youtube.com') || text.includes('youtu.be');
}
```

**Step 2: Commit**

```bash
git add src/main.ts
git commit -m "feat: add context menu integration"
```

---

## Task 21: Error Handling Polish

**Files:**
- Modify: `src/services/extraction.ts`

**Step 1: Add comprehensive error handling**

Modify `src/services/extraction.ts`:

```typescript
export class ExtractionService {
  // ... existing code ...

  async extract(url: string): Promise<void> {
    try {
      // Validate URL first
      if (!this.youtubeService.isValidYouTubeUrl(url)) {
        throw new Error('Invalid YouTube URL');
      }

      // Step 1: Fetch YouTube data
      this.statusBar.show('Fetching transcript...');
      let youtubeData;
      try {
        youtubeData = await this.youtubeService.extractVideoWithRetry(url);
      } catch (error) {
        youtubeData = await this.handleYouTubeError(error, url);
      }

      // Step 2: Generate LLM summary
      let llmResponse;
      try {
        this.statusBar.update('Generating summary...');
        llmResponse = await this.llmService.generateSummary(youtubeData.transcript);
      } catch (error) {
        llmResponse = await this.handleLLMError(error);
      }

      // Step 3: Process template
      this.statusBar.update('Saving note...');
      const templateData = this.templateService.buildTemplateData(youtubeData, llmResponse);

      let content;
      try {
        content = await this.templateService.processTemplate(templateData);
      } catch (error) {
        content = await this.handleTemplateError(error, templateData);
      }

      // Step 4: Save file
      const filename = this.templateService.generateFilename(templateData);
      const filepath = this.templateService.getFilePath(filename);
      const finalPath = await this.templateService.resolveFileNameConflict(filepath);

      await this.saveFile(finalPath, content);

      // Success
      this.statusBar.showSuccess('Note created successfully');
      new Notice(`Created: ${finalPath}`);

    } catch (error) {
      this.handleError(error);
    }
  }

  private async handleYouTubeError(error: Error, url: string): Promise<any> {
    const behavior = this.settings.errorBehavior;

    if (behavior === 'stop') {
      throw error;
    }

    // Extract video ID for partial data
    const videoId = this.youtubeService.extractVideoId(url);

    if (behavior === 'partial' || behavior === 'skip') {
      new Notice(`Warning: ${error.message}. Creating partial note.`);
      return {
        metadata: {
          title: 'Unknown Video',
          url: url,
          videoId: videoId || '',
          channel: 'Unknown'
        },
        transcript: behavior === 'skip' ? 'Transcript unavailable' : '',
        timestampedTranscript: []
      };
    }

    throw error;
  }

  private async handleTemplateError(error: Error, templateData: any): Promise<string> {
    new Notice('Warning: Template error, using fallback');

    // Create simple fallback content
    return `# ${templateData.title}

URL: ${templateData.url}
Channel: ${templateData.channel}

## Transcript
${templateData.transcript}`;
  }

  // ... rest of the code ...
}
```

**Step 2: Commit**

```bash
git add src/services/extraction.ts
git commit -m "feat: add comprehensive error handling"
```

---

## Task 22: README Documentation

**Files:**
- Create: `README.md`

**Step 1: Write README**

```markdown
# YouTube Transcript Extractor

An Obsidian plugin that extracts YouTube video transcripts, generates AI-powered summaries using local LLMs, and saves formatted notes to your vault.

## Features

- 📝 Extract YouTube transcripts without API keys
- 🤖 Generate summaries using local LLMs (Ollama, LM Studio, llama.cpp)
- 📄 Customizable templates with variable substitution
- ⚙️ Flexible settings for metadata, naming, and error handling
- 🎨 Multiple entry points: command palette, ribbon icon, context menu
- 📊 Status bar progress feedback

## Installation

### From Obsidian Community Plugins (Recommended)

1. Open Settings > Community Plugins
2. Disable Safe Mode
3. Browse and search for "YouTube Transcript Extractor"
4. Install and enable the plugin

### Manual Installation

1. Download the latest release
2. Extract files to `.obsidian/plugins/ytextract/`
3. Reload Obsidian
4. Enable plugin in Settings > Community Plugins

## Usage

### Extract a Video

**Command Palette:**
1. Press `Ctrl/Cmd + P`
2. Type "Extract YouTube Video"
3. Paste YouTube URL
4. Click Extract

**Ribbon Icon:**
1. Click YouTube icon in left sidebar
2. Paste URL and extract

**Context Menu:**
1. Select YouTube URL in editor
2. Right-click > "Extract YouTube Video"

## Configuration

### File Management
- **Default folder**: Where to save extracted videos
- **Naming pattern**: File naming with variables: `{date}`, `{title}`, `{channel}`, `{id}`
- **Template path**: Custom template file path

### LLM Configuration
- **Provider**: Ollama, LM Studio, llama.cpp, or custom
- **Auto-detect**: Automatically find available LLM
- **Model**: LLM model name
- **System prompt**: Customize LLM instructions
- **Output options**: Summary, key points, tags, questions

### Template Variables

Available variables for custom templates:

**Video Metadata:**
- `{{title}}`, `{{url}}`, `{{channel}}`
- `{{upload_date}}`, `{{duration}}`, `{{view_count}}`
- `{{description}}`, `{{channel_url}}`, `{{thumbnail_url}}`

**LLM Outputs:**
- `{{llm_summary}}`, `{{llm_key_points}}`
- `{{generated_tags}}`, `{{llm_questions}}`

**Transcript:**
- `{{transcript}}` - Plain text
- `{{transcript_timestamped}}` - With timestamps

## Requirements

- Obsidian v0.15.0 or higher
- Local LLM server (optional but recommended)
  - Ollama, LM Studio, or llama.cpp

## Support

Report issues: [GitHub Issues](https://github.com/yourusername/ytextract/issues)

## License

MIT
```

**Step 2: Commit**

```bash
git add README.md
git commit -m "docs: add comprehensive README"
```

---

## Task 23: Final Build and Testing

**Files:**
- All source files

**Step 1: Run final build**

Run: `npm run build`
Expected: Build succeeds with no errors

**Step 2: Test in Obsidian**

1. Copy plugin to Obsidian vault: `.obsidian/plugins/ytextract/`
2. Reload Obsidian
3. Enable plugin
4. Test command palette
5. Test ribbon icon
6. Test extraction with real YouTube URL

**Step 3: Verify all features**

Checklist:
- [ ] Settings tab displays correctly
- [ ] URL validation works
- [ ] YouTube extraction works
- [ ] LLM integration works (with LLM running)
- [ ] Template processing works
- [ ] File creation works
- [ ] Status bar updates work
- [ ] Error handling works gracefully

**Step 4: Final commit**

```bash
git add .
git commit -m "chore: final build and testing complete"
git tag v1.0.0
```

---

## Completion

The YouTube Transcript Extractor plugin is now complete with all core features implemented:

✅ URL parsing and validation
✅ YouTube transcript and metadata extraction
✅ Multiple LLM provider support with auto-detection
✅ Template processing with variable substitution
✅ Complete UI with modal, ribbon, and context menu
✅ Status bar progress feedback
✅ Comprehensive error handling
✅ Full settings configuration
✅ Documentation

The plugin is ready for use and can be tested in Obsidian!
